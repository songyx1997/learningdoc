#### 什么是`CSRF`？如何避免？

`CSRF`攻击的大致方式如下：某用户登录了A网站，认证信息保存在`cookie`中。当用户访问攻击者创建的B网站时，攻击者通过在B网站发送一个伪造的请求提交到A网站服务器上，让A网站服务器误以为请求来自于自己的网站，于是执行响应的操作。

除了使用`token`外，可采用的方式：

1. 基于用户交互的验证：敏感操作，需要验证码，或者进行二次认证。
1. 敏感请求使用`post`：因为`GET`请求很容易被嵌入到链接或图片标签中发起。
1. 检查`Referer`头：服务器可以根据此头判断请求是否来自于预期的域名。但是这种方法并不十分可靠，因为`Referer`头可能被浏览器设置、隐私插件或中间代理所屏蔽或篡改，并且不能用于保护`HTTPS`到`HTTP`的请求（因为这些请求默认不会携带`Referer`头）。
1. 检查`Origin`头：对于支持`CORS（跨源资源共享）`的现代浏览器，可以通过检查`Origin`头来确定请求的来源域是否与预期相符。
1. 使用`Cookie`的`SameSite`属性：将该属性设置为`Strict`，可以阻止浏览器在跨域请求中携带这些`Cookie`。

#### 什么是三次握手？

1. 客户端发送`SYN`。
2. 服务端发送`SYN+ACK`（`ACK`是客户端的`SYN`+1，这样客户端收到`ACK`时，`-1`就可以知道自己发送的`SYN`是否得到响应）。
3. 客户端发送`ACK`（因为服务端无法确认自己发送的`ACK`是否被客户端接收了，需要客户端再发送一次请求，建立连接，其值为服务端序号+1）。

**确认号`ACK`都是根据序号`SYN`+1得到的。**

<div style="margin:0 auto;border:2px solid #42b883">
    <img src=".\三次握手.png">
</div>

#### 什么是四次挥手？

TCP连接是双向的，即全双工通信，因此关闭连接时需要独立地关闭连接的两个方向，这就是为什么需要四次挥手而非两次的原因。

1. 客户端发送`FIN+ACK`。
2. 服务端响应`ACK`（表示确认收到了客户端的关闭请求，此时从客户端到服务器的方向已经停止数据传输）。
3. 服务端发送`FIN+ACK`（表示服务器也完成了数据发送任务）。
4. 客户端响应`ACK`。

<div style="margin:0 auto;border:2px solid #42b883">
    <img src=".\四次挥手.png">
</div>

#### 什么是XSS攻击？如何避免？

`XSS`攻击被称为跨站脚本攻击，包括三种类型：

1. 反射型：黑客`URL` > 用户检索该`URL` > 服务器无过滤，不保存 > 服务器反射信息 > 执行脚本。由于`URL`的一部分被展示在页面中，如果服务器没有对`URL`进行过滤，当`URL`中包含`js`脚本时，就会被执行。
2. 存储型：常见于可以发表评论的网站。恶意脚本作为评论 > 服务器无过滤，存储 > 每个用户正常访问，都被迫看到有恶意代码的评论 > 浏览器执行恶意代码。
3. `DOM`型：黑客寻找源码中是否有可操作的**属性**与**方法**。在`URL`中添加脚本修改操作该属性的方法。

如何避免？

1. 对**用户输入**进行过滤，过滤非法字符。
2. `html`转义，如`JavaScript`的`encodeURI()`，`encodeURIComponent()`。
3. 限制输入长度。
4. `cookie`设置`HttpOnly`和`SameSite`。

#### for-in和for-of的区别？

`for-in`会遍历对象的所有可枚举`（enumerable：true）`属性（包括**原型链**上的属性），并且属性名的顺序是不确定的。

如果你只想遍历对象的自身属性，可以使用 `Object.keys()` 方法来获取对象的所有键名，然后使用 `for-of` 循环来遍历这些键名对应的值。

`for-of`用于遍历可迭代对象的每一个元素。

#### 为什么需要虚拟DOM？

<div style="margin:0 auto;border:2px solid #42b883">
    <img src=".\虚拟DOM.png">
</div>

从上图可以看出，使用原生js的效率是否更高？

当数据变化时，原生`js`无法确切知道是哪一块发生了变化，会去重新生成全部真实`DOM`，完成更新。

1. 框架设计。使用框架时，当数据发生变化。为了确定应该修改哪个`DOM`。框架全量生成新的虚拟`DOM`树，与之前的虚拟`DOM`树使用`diff`算法，计算出需要更新的真实`DOM`。
2. 跨平台。虚拟`DOM`是一个普通对象来表达`UI`界面，最后根据平台生成真实`DOM`。

#### JS中的计时是否精确？

1. 浏览器，浏览器本身不会计时，而是调用操作系统的计时接口。也就是说，计时在操作系统层面的实现就存在差异。
2. `W3C`标准，当计时的嵌套`>=5`时，即使将时间间隔均设置为`0`，最小仍然是`4ms`。
3. 事件循环，回调函数被加入宏任务，当到达时间时，按理说需要执行。但是执行的前提，需要将执行栈中的代码全部执行完毕。

#### 性能优化指标？

1. 首屏加载时间`(FCP-First Contentful Paint)`：首次内容绘制时间，指浏览器首次绘制页面中至少一个元素的时间。
2. 最大内容绘制时间`(LCP-Largest Contentful Paint)`：最大内容绘制时间，指页面上最大的可见元素绘制完成的时间。

#### 首屏加载优化？

1. `CDN`（内容分发网络）加速，利用`CDN`缓存静态资源。当前端项目采用微前端时，每一个项目都会使用`Vue`、`vuex`、`vue-router`，如果都打包会造成重复，而且这些依赖的打包体积较大。这些资源就可以放在`CDN`上，这样当访问应用的不同微前端模块时，就可以公用同一份，且这一份是存在缓存的。
2. 图片懒加载、路由懒加载（`webpack`的代码分割）。
3. 小图片的合并或编译为`Base64`格式，减少`HTTP`请求次数。
4. `webpack`代码压缩。
5. `HTTP`缓存：强缓存`(Cache-Control: max-age=3600)`、协商缓存`(Last-Modified: Wed, 21 Oct 2020 07:28:00 GMT)`。
6. 预加载`(preload)`：暗中加载当前页面的资源，存在浏览器兼容问题。
7. 首屏内容优先级标记：关键`js、css`优先加载，其他采用懒加载。并且`js`的加载使用`defer`标记，异步加载。
8. 针对低版本浏览器，`babel`常常会导致较大的打包体积。因此可以采用两份打包结果（一份高版本、一份低版本），根据用户的环境，在`HTML`中引入不同的文件。

```html
<!-- 为支持模块的现代浏览器提供ES6模块 -->
<script type="module" src="modern-browser-module.js"></script>
<!-- 为不支持模块的老式浏览器提供传统脚本 -->
<script nomodule src="legacy-browser-script.js"></script>
```

#### 使用defer优化白屏时间？