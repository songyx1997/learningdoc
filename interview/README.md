#### 什么是`CSRF`？如何避免？

`CSRF`攻击的大致方式如下：某用户登录了A网站，认证信息保存在`cookie`中。当用户访问攻击者创建的B网站时，攻击者通过在B网站发送一个伪造的请求提交到A网站服务器上，让A网站服务器误以为请求来自于自己的网站，于是执行响应的操作。

除了使用`token`外，可采用的方式：

1. 基于用户交互的验证：敏感操作，需要验证码，或者进行二次认证。
1. 敏感请求使用`post`：因为`GET`请求很容易被嵌入到链接或图片标签中发起。
1. 检查`Referer`头：服务器可以根据此头判断请求是否来自于预期的域名。但是这种方法并不十分可靠，因为`Referer`头可能被浏览器设置、隐私插件或中间代理所屏蔽或篡改，并且不能用于保护`HTTPS`到`HTTP`的请求（因为这些请求默认不会携带`Referer`头）。
1. 检查`Origin`头：对于支持`CORS（跨源资源共享）`的现代浏览器，可以通过检查`Origin`头来确定请求的来源域是否与预期相符。
1. 使用`Cookie`的`SameSite`属性：将该属性设置为`Strict`，可以阻止浏览器在跨域请求中携带这些`Cookie`。

#### 什么是三次握手？

1. 客户端发送`SYN`。
2. 服务端发送`SYN+ACK`（`ACK`是客户端的`SYN`+1，这样客户端收到`ACK`时，`-1`就可以知道自己发送的`SYN`是否得到响应）。
3. 客户端发送`ACK`（因为服务端无法确认自己发送的`ACK`是否被客户端接收了，需要客户端再发送一次请求，建立连接，其值为服务端序号+1）。

**确认号`ACK`都是根据序号`SYN`+1得到的。**

<div style="margin:0 auto;border:2px solid #42b883">
    <img src=".\三次握手.png">
</div>

#### 什么是四次挥手？

TCP连接是双向的，即全双工通信，因此关闭连接时需要独立地关闭连接的两个方向，这就是为什么需要四次挥手而非两次的原因。

1. 客户端发送`FIN+ACK`。
2. 服务端响应`ACK`（表示确认收到了客户端的关闭请求，此时从客户端到服务器的方向已经停止数据传输）。
3. 服务端发送`FIN+ACK`（表示服务器也完成了数据发送任务）。
4. 客户端响应`ACK`。

<div style="margin:0 auto;border:2px solid #42b883">
    <img src=".\四次挥手.png">
</div>

#### 什么是XSS攻击？如何避免？