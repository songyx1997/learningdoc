// 给你一个非负整数数组 nums ，你最初位于数组的 第一个下标 。数组中的每个元素代表你在该位置可以跳跃的最大长度。
// 判断你是否能够到达最后一个下标，如果可以，返回 true ；否则，返回 false 。

// 输入：nums = [3,2,1,0,4]
// 输出：false
// 解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。

// 贪心算法
// 局部最优：维护一个较大的覆盖范围，当可以更新使之变大时，就更新！
// 一、
// [3, 2, 1, 0, 4]
//  ----------
//  ----------
//  ----------
// 覆盖范围无法继续增长

// 二、
// [2, 3, 1, 1, 4]
//  -------
//  -------------
// 此时覆盖范围已经和数组长度相同，一定可以到达最后一个下标

const canJump = function (nums) {
    if (nums.length === 1) {
        return true;
    }
    let cover = nums[0] + 1;
    // i < cover是本题的关键，只能在覆盖范围内移动
    for (let i = 1; i < cover; i++) {
        if (cover >= nums.length) {
            return true;
        }
        cover = Math.max(cover, i + nums[i] + 1);
    }
    return false;
};

console.log(canJump([2, 3, 1, 1, 4]));